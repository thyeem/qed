#!/bin/bash

# Prerequisite ----------------------------------------
# $ brew install zbar qrencode imagemagick ffmpeg

# Edit-Zone -------------------------------------------

# splitter binary
SPLITTER=split

# hasher binary
HASHER=sha256sum

# file compressor binary
ZIPPER=gzip

# default minimum of QR-version: an integer between 1 and 40
QR_VERSION=38

# default QR-error-correction-level: one of [L,M,Q,H]
QR_ERROR_CORRECTION=L

# default QR-cell size
QR_CELL_SIZE=15

# default cell margin in QR Code area
QR_MARGIN=8

# default foreground-color of QR Code [6-hexadecimal]
QR_FOREGROUND="000000"

# default background-color of QR Code [6-hexadecimal]
QR_BACKGROUND="ffffff"

# default image ratio to original when resizing
QR_RESIZE_RATIO=30%

# default framerate when playing slideshow
SLIDE_SHOW_FRAMERATE=0.5


# Header Definition ---------------------------------------------------

# the header bytes are to provide some information when decoded.
#
# header(HEADER_BYTES) := [hash:HASH_ID_BYTES]
#                       + [index:INDEX_BYTES]
#                       + [size:INDEX_BYTES]

HASH_ID_BYTES=6

INDEX_BYTES=3

HEADER_BYTES=$(($HASH_ID_BYTES + ${INDEX_BYTES}*2))

# 'capcode' or Capaicty-Code means the amount of data can be stored.
# This consists of version, error correction level and the data type
#
# capcode = [version:2-byte]
#         + [error-coorection-level:1-byte]
#         + [datatype:1-byte]  (fixed to binary)
#
# error-correction-level: one of [L,M,Q,H]
# version of QR code: 1 to 40 (padded two-digit, %02d)
# datatype: others are not very useful, so it was fixed as binary

# ---------------------------------------------------------------------

stderr-msg () {
    # -> stderr messages
    # <- $@: all messages passed
    if [[ -n $verbose || $1 -gt 0 ]]; then
        shift
        >&2 echo
        >&2 echo -e "$@" "\t"
    fi
}


error () {
    # -> exit status
    # <- $@: all messages passed
    stderr-msg 1 $(red error) "\t" $@
    exit 1
}

ok () {
    # -> exit status
    # <- $1: ok message
    stderr-msg 1 -n $(green ok) "\t"
    echo $1
}

red () {
    # -> ansi-escaped text
    # <- $1: text to colorize red
    echo -e "\033[0;31m$1\033[0m"
}


green () {
    # -> ansi-escaped text
    # <- $1: text to colorize green
    echo -e "\033[0;32m$1\033[0m"
}


abspath () {
    # -> absolute path
    # <- $1: filepath
    local dir=$(cd $(dirname $1); pwd -P)
    local fname=$(basename $1)
    echo -n $dir/$fname;
}


lower () {
    # -> lowercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print lc'
}


upper () {
    # -> uppercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print uc'
}


hash-id () {
    # -- get a hash value using a given hasher
    #
    # -> sized hex-string
    # <- $1: filename - if not provided, use stdin
    if [ $# -gt 0 ]; then
        # when used with args: hash-id STRING
        echo -n $($HASHER "$1" | head -c $HASH_ID_BYTES)
    else
        # when used with stdin: cat FILE | hash-id
        echo -n $(cat - | $HASHER | head -c $HASH_ID_BYTES)
    fi
}


random-bytes () {
    echo -n $(cat /dev/urandom | head -c 32)
}


tmp-filepath () {
    # -> tmp filepath string
    echo -n "/tmp/$(random-bytes | $HASHER | head -c 16)"
}


assert-dir () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -rf $1; mkdir -p $1
}


assert-file () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -f $1; :> $1
}


are-you-sure () {
    # -> exit status
    # <- $1: filepath
    if [ -e "$1" ]; then
        >&2 echo
        read -n 1 -rp "Are you sure to delete $1? [y/N] " < /dev/tty
        >&2 echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            return 0
        else
            exit 1
        fi
    else
        return 0
    fi
}


decimal-to-binary () {
    # -> binary-form string
    # <- $1: decimal-form string
    # <- $2: (optional) size of output. if not provided, use the minimum length
    local n=$1
    local size=$2
    if [ -z $size ]; then
        while true; do
            size=$((size + 1))
            [[ $n -lt $((2 ** $size)) ]] && break
        done
    fi

    local r=
    for _ in $(seq $size); do
        b="$b$(echo -n $(($n & 1)))"
        ((n >>= 1))
    done
    echo -n $b | rev
}


get-capcode () {
    # -> capcode-string
    # <- $1: version
    # <- $2: correction level
    echo -n "$(printf %02d $version)$level"
}


find-max-qr-encoding-byte () {
    # -- find maximum bytes that can be encoded with the given capcode
    # --
    # -> max-QR-storage-byte number
    # <- $1: capcode
    local filter="${1:0:2}_${1:2:1}"
    grep -A 1 "^__QR_MAX_BYTES_DEF__$" $0 | tail -1             \
                                          | base64 -d           \
                                          | gunzip -c           \
                                          | grep "$filter"      \
                                          | awk -F: '{print$2}' \
        || error "problems finding QR Code max-encoding bytes: $filter"
}


split-data () {
    # -- split the given buffer if large enough
    #
    # -> void
    # <- $1: in
    # <- $2: bytes
    # <- $3: prefix
    $SPLITTER -b $(($2 - $HEADER_BYTES)) -a ${INDEX_BYTES} "$1" "$3" \
        || error "occurred problem while splitting data in: $(pwd)"
}


write-header-and-qrencode () {
    # -- write a header to each token and encode it into a QR Code
    #
    # -> void
    # <- $1: _hash
    # <- $2: size
    # <- $3: margin
    # <- $4: version
    # <- $5: level
    # <- $6: fcolor
    # <- $7: bcolor
    stderr-msg 0 -n "."
    local total=$(printf %0${INDEX_BYTES}d $(ls -1 _ | wc -l))
    local it=1
    for f in $(ls -1 _ | sort); do
        local o="$f.png"
        local header="$1$(printf %0${INDEX_BYTES}d $it)$total"
        stderr-msg 0 -n "processing  $1" \
                        "[$(printf %0${INDEX_BYTES}d $it) / $total]  >>  $(pwd)/$o"

        # write header to split file
        echo -n $header | cat - "_/$f" > _/_ && mv _/_ "_/$f"

        # encode each split file into QR Code
        cat "_/$f" | qrencode -8               \
                              -s $2            \
                              -m $3            \
                              -v $4            \
                              -l $5            \
                              -o $o            \
                              --foreground=$6  \
                              --background=$7  \
            || error "occurred problem while encoding data into QR Code: $(pwd)/$f"
        it=$((it+1))
    done
    rm -rf _
}


create-video-and-play-slideshow () {
    # -> void
    # <- $1: video-file-basename
    local mp4="$1.mp4"
    local n=$(ls -1 *.png | wc -l)
    local t=$(echo "scale=0;1/$SLIDE_SHOW_FRAMERATE*$n+2" | bc)
    stderr-msg 0 "generating $mp4"

    # converting encoded images into video file
    ffmpeg -y -hide_banner                   \
           -loglevel error                   \
           -stats                            \
           -loop 1                           \
           -framerate $SLIDE_SHOW_FRAMERATE  \
           -t $t                             \
           -pattern_type glob                \
           -i '*.png'                        \
           -s hd720                          \
           $mp4                              \
        || error "occurred problem while creating the slideshow: $mp4"
    stderr-msg 0 "opening $mp4"
    open $mp4
}


quick-view-on-browser () {
    # -> void
    # <- $1: html-file-basename
    local html="$1.html"
    echo -e "<!DOCTYPE html>" > $html
    echo -e "<head><title>qed-encoded</title></head>" >> $html
    echo -e "<body><center>" >> $html
    for f in $(ls -1 | sort); do
        echo -e "<p><img src=\"$(abspath $f)\" width="1000"></p>" >> $html
    done
    echo -e "</center></body><html>" >> $html
    stderr-msg 0 "opening $html"
    open $html
}


encode () {
    # -- the outermost encoding wrapper function
    # -- single encoding process is performed for a given file
    #
    # -> void
    # <- $1: out
    # <- $2: in
    # <- $3: size
    # <- $4: margin
    # <- $5: version
    # <- $6: level
    # <- $7: fcolor
    # <- $8: bcolor

    # get capcode or capaicty-code, meaning the amount of data can be stored.
    capcode=$(get-capcode $version $level)

    # get maximum bytes that can be encoded with the given capcode
    bytes=$(find-max-qr-encoding-byte $capcode)

    # guard on 'bytes' variable
    [[ -z $bytes ]] && \
        error "failed to get QR-max-encoding-byte." \
              "\n\t check if the values of -l, -t, and -V are set correctly."

    # get a hash-id-key for data
    local _hash=$(hash-id "$2")

    # tmp working directory
    t=$(tmp-filepath)
    assert-dir "$t/_"
    cd $t

    # split the given buffer if it is large enough
    split-data "$2" $bytes "$t/_/${_hash}-"

    # try QR-encoding with the generated header
    write-header-and-qrencode $_hash \
                              $3     \
                              $4     \
                              $5     \
                              $6     \
                              $7     \
                              $8

    stderr-msg 0 "completed.  each QR Code encoded in:" \
                 "$bytes bytes (including ${HEADER_BYTES}-byte header)\n"

    # quick-view encoded images on browser (if -q is set)
    [[ -n $view ]] && quick-view-on-browser "$t-$capcode"

    # play slideshow after generating video from images (if -p is set)
    [[ -n $slideshow ]] && create-video-and-play-slideshow "$t-$capcode"

    # output: write to file or to stdout in tar format
    if [ -n "$1" ]; then
        ls -1 *.png | tar -cf "$1" -T - \
            && ok "$1" \
            || error "problem occurred while writing to file: $1"
    else
        ls -1 *.png | tar -c -T - \
            || error "problem occurred while writing to stdout"
    fi
}


adjust-resize-ratio () {
    # -> auto-adjusted ratio
    # <- $1: version of QR code
    echo "auto-adjusted"
}


decode-qrcode-image () {
    # -> void
    # <- $1: qrcode image file
    # <- $2: dirname where decoded files are collected
    # <- $3: resize ratio to original

    # resize
    convert -resize "${3}%" $1 __ \
        || error "occurred problem during resizing QR Code image: $1"

    # decode each iamge using zbar
    zbarimg --raw --quiet -Sbinary __ > _ \
        || error "occurred problem during decoding QR Code image: $1"

    # parse header
    local header=$(cat _ | head -c $HEADER_BYTES)
    [[ ${#header} -eq $HEADER_BYTES ]] \
        || error "something wrong with the header: $header"

    stderr-msg 0 -n \
                 "processing  ${header:0:$HASH_ID_BYTES}" \
                 "[${header:$HASH_ID_BYTES:$INDEX_BYTES} /" \
                 "${header:$((HEADER_BYTES-$INDEX_BYTES)):$INDEX_BYTES}]" \
                 " <<  $1"
    cat _ | tail -c +$((HEADER_BYTES + 1)) > "$2/$header"
    rm -f __ _
}

find-hashes-of-uniq-files () {
    # -> many hash strings (blank separated)
    # no input, but this function depends on the directory location.
    local awk=`echo {print substr\(\\$0,3,$HASH_ID_BYTES\)}`
    echo -n $(find . -size +0c | awk "$awk" | sort | uniq)
}

merge-decoded-files () {
    # -> void
    # <- $1: filepath of merged files
    # <- $2: hash value that the merged file is expected to have
    local f="$1/$2"
    ls -1 | grep $2 | sort | xargs cat > $f \
        || error "problem occurred during merging decoded files: $f"

    # check if the decoded is valid
    [[ "$2" == "$(cat $f | hash-id)" ]] \
        || error "Not matched hash value of file: $f" \
                 "\n\t expected $2, but got $(cat $f | hash-id)"
}

decode () {
    # -- the outermost decoding wrapper function
    #files
    # <- $1: out: output tarball filename
    # <- $2: dir containing files to be decoded
    stderr-msg 0 -n "."
    cd $2

    # where decoded files are collected
    local decoded="$(tmp-filepath)"
    assert-dir "$decoded"

    # decoding from images
    for f in $(find . | file --mime -f -       \
                      | grep "image/*"         \
                      | awk -F: '{print$1}'    \
                      | sort); do
        decode-qrcode-image $f $decoded $ratio \
            || error "failed to decode QR code image: $f"
    done

    cd "$decoded"

    # merge files
    local merged=$(tmp-filepath)
    assert-dir $merged
    for _hash in $(find-hashes-of-uniq-files); do
        merge-decoded-files $merged $_hash \
            || error "failed to merge files with expected hash of: $_hash"
    done

    cd "$merged"

    # extract decoded archives
    for f in *; do
        tar -xf $f \
            || error "failed to extract decoded archive: $f"
        rm -f $f
    done

    # output
    stderr-msg 0
    if [ -n "$1" ]; then
        mv -f $merged "$1"
        ok "$1"
    else
        find . -type f | sort | xargs cat
    fi
}


print-help () {
    local this=$(basename $0)
    cat << HELP
 qed - encode data of any size into tarballs of QR Code

 Usage: $this [-hdpqzv] [-o output] [-s cell-size] [-m margin]
            [-V version] [-l error-correction-level]
            [-1 qr-fg-color] [-0 qr-bg-color] [-r resize-ratio ] filepath

      -h    print this message
      -d    decode input
      -p    create and play QR Code slideshows after encoding is finished
      -q    open output QR Code images in browser after encoding is finished
      -z    compress output tarball of QR code
      -v    show in detail how the work is progressing
      -o    set output file                  (default: '-' for stdout)
      -s    set cell size of QR Code         (default: $QR_CELL_SIZE)
      -m    set margin of QR Code            (recommended 4+, default: $QR_MARGIN)
      -1    set foreground color of QR Code  (6-hexadecimal, default: $QR_FOREGROUND)
      -0    set background color of QR Code  (6-hexadecimal, default: $QR_BACKGROUND)
      -r    set resize-ratio if needed       (6-hexadecimal, default: $QR_RESIZE_RATIO)
      -V    set version of QR Code           (1 to 40, default: $QR_VERSION)
      -l    set error correction level       (one of [L,M,Q,H], default: $QR_ERROR_CORRECTION)
HELP
    exit 0
}



# --------------
# qed main
# --------------
# process options
while getopts hdpqzvo:s:m:1:0:r:V:l: flag
do
    case "${flag}" in
        h) print-help;;
        d) decode=${OPTARG:-set};;
        p) slideshow=${OPTARG:-set};;
        q) view=${OPTARG:-set};;
        z) zip=${OPTARG:-set};;
        v) verbose=${OPTARG:-set};;
        o) out=${OPTARG};;
        s) size=${OPTARG};;
        m) margin=${OPTARG};;
        1) fcolor=${OPTARG};;
        0) bcolor=${OPTARG};;
        r) ratio=${OPTARG};;
        V) version=${OPTARG};;
        l) level=${OPTARG};;
    esac
done
shift $((OPTIND - 1))

# set fallbacks
size=${size:-$QR_CELL_SIZE}
margin=${margin:-$QR_MARGIN}
fcolor=${fcolor:-$QR_FOREGROUND}
bcolor=${bcolor:-$QR_BACKGROUND}
ratio=${ratio:-$QR_RESIZE_RATIO}
version=${version:-$QR_VERSION}
level=${level:-$QR_ERROR_CORRECTION}
[[ $out == "-" ]] && out=


# decoding:
if [[ -n $decode ]]; then

    # when used with stdin
    if [[ -p /dev/stdin || $# -eq 0 ]]; then
        in="$(tmp-filepath)"
        assert-dir "$in"
        cat - | tar -x -C "$in" &>/dev/null \
            || error "entered an unacceptable format: must be a tarball or dir"

    # when used with arguments
    else
        f="$1"
        [[ ! -e $f ]] && error "filepath not found: $f"
        if [ -d $f ]; then
            in=$f
        else
            tar -tf $f &>/dev/null \
                || error "the target to be decoded must be a tarball or dir: $f"
            in="$(tmp-filepath)"
            assert-dir "$in"
            tar -xf $f -C "$in"
        fi
    fi

    # check if there's anything to decode
    [[ $(find $in | file --mime -f -     \
                  | grep "image/*"       \
                  | awk -F: '{print$1}'  \
                  | wc -l) -gt 0 ]]      \
        || error "nothing to decode: $1"

    # prepare output name (if any). stdout by default
    if [ -n "$out" ]; then
        out=$(abspath $out)
        are-you-sure $out && rm -rf $out
    fi
    decode "$out" "$in"


# encoding:
else
    # when used with stdin
    if [[ -p /dev/stdin || $# -eq 0 ]]; then
        f="$(tmp-filepath)"
        cat - > $f

    # when used with arguments
    else
        f="$1"
        [[ ! -e $f ]] && error "filepath not found: $f"
    fi

    # prepare output name (if any). stdout by default
    if [ -n "$out" ]; then
        out=$(abspath $out)
        are-you-sure $out && rm -rf $out
    fi

    # prepare input file to encode
    in="$(tmp-filepath).tar.gz"
    cd $(dirname $f) && tar -c $(basename $f) | $ZIPPER -c > $in \
        || error "problem occurred while archiving file: $f"

    encode "$out"      \
           "$in"       \
           "$size"     \
           "$margin"   \
           "$version"  \
           "$level"    \
           "$fcolor"   \
           "$bcolor"
fi

exit 0
# q.e.d.

__QR_MAX_BYTES_DEF__
H4sICObg+2IAA3FyLW1heC1kYXRhACWUy5XlIBBD9y8aqgowEIEX44Uj6PyzGF15xW2h80yrPi3+/p24fi3+nhOd8z0RnPeRnLqu5HxOTs73ZOO8bS/dj+J8Tk/O1/7Sfeq+6/5anM+ZyfmePjnvU7offL5N4DnLwntm47xP198TQxmezznluCzcZ+inLxyjA3JkAu9Zk/M+UxcLx05AjmHQf9kWcPuzW5asBsiyDLJ8yn32+kXDcgWgLKIAWYYVpRH7F+G4ApBnGOS5LkCeEjjSaZBnGQi1AHnG+AWx9jQ8pyoAebrh/n6QaLsCCLIthRuEm58iz+6/IN6hegXx9khAnm1Qhbgi4aG4goT7sEIRE5AHhYynyhFkPJpBnmmQR4EFKV+xAHmmFXl4BilXSCHmi69v90MH1BDdijy1fknOaxjkmROQZyUgD0DOOzfw6KMBvHqYFTWOwsx0a30k07UBmeYAZCopZdMOSA04LkAdGFZkmgKSjrhMz9lhkOm7UxeiuJPzKkimfQHq1BiATCX4ulnFz6+dx4bkUqukG3rrB9zRnXe6pSNN6ulmUFOjuKtHLgjXbhCdb0kuQiTxmGliPFSyJPPdLMml3q7mLaDBLUJXmzZIrmVJq0AlKu+K1RvEthjWmKSyJpseUQ5+c5meNxW10mslrDFxAqLPpscW0fuNVbZ9mmw8jfAzlkm2S31ZpK9Jt6bh1P9Z4xvggjzBG8K2rDHDAgqQXQNVLgC1rOlJH6aboogoQY5ZEL61Ifl6WsOnUhVFyLk3pGluH+H7iL2gPivvFz+KMiTro7xhxmVNvtQC6V4yWxu1e8sw+t1rZk5r99dj/wGs8WlBtwUAAA==
