#!/bin/bash


# PREREQUISITE ----------------------------------------
# $ brew install zbar qrencode imagemagick ffmpeg

# EDIT-ZONE -------------------------------------------

# splitter binary
SPLITTER=split

# hasher binary
HASHER=sha256sum

# default QR-error-correction-level: one of [L,M,Q,H]
QR_ERROR_CORRECTION=L

# default minimum of QR-version: an integer between 1 and 40
QR_VERSION=38

# default QR-cell size
QR_CELL_SIZE=15

# default cell margin in QRcode area
QR_MARGIN=8

# default foreground-color of QRcode [6-hexadecimal]
QR_FOREGROUND="000000"

# default background-color of QRcode [6-hexadecimal]
QR_BACKGROUND="ffffff"

# default image ratio to original when resizing
QR_RESIZE_RATIO=25%

# default type of input data: one of [A,B,D,K,N]
QR_DATA_TYPE=B

# default framerate when playing slideshow
SLIDE_SHOW_FRAMERATE=0.5


# HEADER BYTES DEFINITION -------------------------------------------------
#
# These bytes in the header are to provide some information when decoded.
#
# header(HEADER_BYTES) := [hash:HASH_ID_BYTES]
#                       + [index:INDEX_BYTES]
#                       + [size:INDEX_BYTES]
#
# 'capcode' or Capaicty-Code means the amount of data can be stored.
# This consists of version, error correction level and the data type
#
# capcode = [version:1-byte]
#         + [error-coorection-level:2-byte]
#         + [datatype:1-byte]
#
# version: one of [L,M,Q,H]
# error-correction-level: 1 to 40 (padded two-digit, %02d)
# datatype: one of [A,B,D,K,N]
# alphanumeric, binary, databits, kanji, and numeric, in the order listed.
#

HASH_ID_BYTES=6

INDEX_BYTES=3

HEADER_BYTES=$(($HASH_ID_BYTES + ${INDEX_BYTES}*2))


# -------------------------------------------------------------------------

stderr-msg () {
    # -> stderr messages
    # <- $@: all messages passed
    >&2 echo
    >&2 echo -e "$@" "\t"
}


error () {
    # -> exit status
    # <- $@: all messages passed
    stderr-msg $(red error) "\t" $@
    exit 1
}


red () {
    # -> ansi-escaped text
    # <- $1: text to colorize red
    echo -e "\033[0;31m$1\033[0m"
}


green () {
    # -> ansi-escaped text
    # <- $1: text to colorize green
    echo -e "\033[0;32m$1\033[0m"
}


abspath () {
    # -> absolute path
    # <- $1: filepath
    local dir=$(cd $(dirname $1); pwd -P)
    local fname=$(basename $1)
    echo -n $dir/$fname;
}


lower () {
    # -> lowercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print lc'
}


upper () {
    # -> uppercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print uc'
}


hash-id () {
    # -- get a hash value using a given hasher
    #
    # -> sized hex-string
    # <- $1: buf - if not provided, use <stdin>
    if [ $# -gt 0 ]; then
        # when used with args: hash-id STRING
        echo -n $(echo "$1" | $HASHER | head -c $HASH_ID_BYTES)
    else
        # when used with <stdin>: cat FILE | hash-id
        echo -n $(cat - | $HASHER | head -c $HASH_ID_BYTES)
    fi
}


random-hex () {
    # -> sized hex-string
    # <- $1: size
    echo -n $(cat /dev/urandom | head -c 32 | $HASHER | head -c $1)
}


sane-temp() {
    # -> random string
    echo -n "/tmp/$(basename $(mktemp))"
}


assert-dir () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -rf $1; mkdir -p $1
}


assert-file () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -f $1; :> $1
}


are-you-sure () {
    # -> exit status
    # <- $1: filepath
    if [ -e $1 ]; then
        read -n 1 -rp "Are you sure to delete $1? [y/N] "
        >&2 echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            return 0
        fi
    else
        return 0
    fi
    exit 1
}


decimal-to-binary () {
    # -> binary-form string
    # <- $1: decimal-form string
    # <- $2: (optional) size of output. if not provided, use the minimum length
    local n=$1
    local size=$2
    if [ -z $size ]; then
        while true; do
            size=$((size + 1))
            [[ $n -lt $((2 ** $size)) ]] && break
        done
    fi

    local r=
    for _ in $(seq $size); do
        b="$b$(echo -n $(($n & 1)))"
        ((n >>= 1))
    done
    echo -n $b | rev
}


select-data-type () {
    # -> datatype string
    # <- $1: datatype char
    case $1 in
        A) echo -n "Alphanumeric";;
        B) echo -n "Binary";;
        D) echo -n "Databits";;
        K) echo -n "Kanji";;
        N) echo -n "Numeric";;
        *) error "no such value for data type: $1";;
    esac
}


gen-capcode () {
    # -> capcode-string
    # <- $1: version
    # <- $2: correction level
    # <- $3: datatype
    echo -n "$(printf %02d $version)$level$datatype"
}


find-max-qr-encoding-byte () {
    # -> max-QR-storage-byte number
    # <- $1: capcode (expected 4-byte like '38LB')
    local datatype=$(select-data-type $datatype)
    local filter="${1:0:2}_${1:2:1}_$datatype"
    grep -A 1 "^__QR_MAX_BYTES_DEF__$" $0 | tail -1             \
                                          | base64 -d           \
                                          | gunzip -c           \
                                          | grep "$filter"      \
                                          | awk -F: '{print$2}' \
        || error "problems finding QRcode max-encoding bytes: $filter"
}


split-data () {
    # -- split the given buffer if large enough
    #
    # -> void
    # <- $1: buf
    # <- $2: bytes
    # <- $3: prefix
    echo "$1" | $SPLITTER -b $(($2 - $HEADER_BYTES)) -a ${INDEX_BYTES} - "$3" \
        || error "occurred problem while splitting data in: $(pwd)"
}


write-header-and-encode () {
    # -- write a header to each token and encode it into a QRcode
    #
    # -> void
    # <- $1: _hash
    # <- $2: size
    # <- $3: margin
    # <- $4: version
    # <- $5: level
    # <- $6: fcolor
    # <- $7: bcolor
    local total=$(printf %0${INDEX_BYTES}d $(ls -1 _ | wc -l))
    local it=1
    for f in $(ls -1 _ | sort); do
        local o="$f.png"
        local header="$1$(printf %0${INDEX_BYTES}d $it)$total"
        stderr-msg -n "processing  $1" \
                      "[$(printf %0${INDEX_BYTES}d $it) / $total]  >>  $o"

        # write header to split file
        echo -n $header | cat - "_/$f" > _/_ && mv _/_ "_/$f"

        # encode each split file into QRcode
        cat "_/$f" | qrencode -8               \
                              -s $2            \
                              -m $3            \
                              -v $4            \
                              -l $5            \
                              -o $o            \
                              --foreground=$6  \
                              --background=$7  \
            || error "occurred problem while encoding data into QRcode: $(pwd)/$f"
        it=$((it+1))
    done
    rm -rf _
}


create-video-and-play-slideshow () {
    # -> void
    # <- $1: video-file-basename
    local mp4="$1.mp4"
    local n=$(ls -1 *.png | wc -l)
    local t=$(echo "scale=0;1/$SLIDE_SHOW_FRAMERATE*$n+2" | bc)
    stderr-msg "generating $mp4"

    # converting encoded images into video file
    ffmpeg -y -hide_banner                   \
           -loglevel error                   \
           -stats                            \
           -loop 1                           \
           -framerate $SLIDE_SHOW_FRAMERATE  \
           -t $t                             \
           -pattern_type glob                \
           -i '*.png'                        \
           -s hd720                          \
           $mp4                              \
        || error "occurred problem while creating the slideshow: $mp4"
    stderr-msg "opening $mp4"
    open $mp4
}


quick-view-on-browser () {
    # -> void
    # <- $1: html-file-basename
    local html="$1.html"
    echo -e "<!DOCTYPE html>" > $html
    echo -e "<head><title>qed-encoded</title></head>" >> $html
    echo -e "<body><center>" >> $html
    for f in $(ls -1 | sort); do
        echo -e "<p><img src=\"$(abspath $f)\" width="1000"></p>" >> $html
    done
    echo -e "</center></body><html>" >> $html
    stderr-msg "opening $html"
    open $html
}


encode () {
    # -- the outermost encoding wrapper function
    # -- single encoding process is performed for a given file
    #
    # -> void
    # <- $1:    output dirname
    # <- $2:    buf
    # <- $3:    buf-name
    # <- $4:    bytes
    # <- $5:    size
    # <- $6:    margin
    # <- $7:    version
    # <- $8:    level
    # <- $9:    fcolor
    # <- ${10}: bcolor

    # print getting encode started
    stderr-msg -n "."
    stderr-msg "encoding input <- $3"

    # get a unique id for data
    local _hash=$(hash-id "$2")

    assert-dir "$1/_"
    split-data "$2" $4 "$1/_/${_hash}-"

    cd $1

    write-header-and-encode $_hash \
                            $5     \
                            $6     \
                            $7     \
                            $8     \
                            $9     \
                            ${10}

    stderr-msg "completed.  each QRcode encoded in:" \
               "$4 bytes (including ${HEADER_BYTES}-byte header)"

    stderr-msg "encoding output -> $1"

    # quick-view encoded images on browser (if -q is set)
    [[ -n $view ]] && quick-view-on-browser "$1-$capcode"

    # play slideshow after generating video from images (if -p is set)
    [[ -n $slideshow ]] && create-video-and-play-slideshow "$1-$capcode"
}


decode-qrcode-image () {
    # -> void
    # <- $1: qrcode image file
    # <- $2: dirname where restored files are collected
    # <- $3: resize ratio to original

    # resize
    convert -resize "${3}%" $1 __ \
        || error "occurred problem during resizing Qrcode image: $1"

    # decode each iamge using zbar
    zbarimg --raw --quiet -Sbinary __ > _ \
        || error "occurred problem during decoding QRcode images: $1"

    # parse header
    local header=$(cat _ | head -c $HEADER_BYTES)
    stderr-msg -n \
               "processing  ${header:0:$HASH_ID_BYTES}" \
               "[${header:$HASH_ID_BYTES:$INDEX_BYTES} /" \
               "${header:$((HEADER_BYTES-$INDEX_BYTES)):$INDEX_BYTES}]" \
               " <<  $1"
    cat _ | tail -c +$((HEADER_BYTES + 1)) > "$2/$header"
    rm -f __ _
}

find-hashes-of-uniq-files () {
    # -> many hash strings (blank separated)
    # no input, but this function depends on the directory location.
    local awk=`echo {print substr\(\\$0,3,$HASH_ID_BYTES\)}`
    echo -n $(find . -size +0c | awk "$awk" | sort | uniq)
}

merge-decoded-files () {
    # -> merged file
    # <- $1: output dirname
    # <- $2: hash value that the merged file is expected to have
    local merged="$1-$2"
    ls -1 | grep $_hash | sort | xargs cat > $merged

    # check if the decoded is valid
    local validity=$( \
                      [[ $2 == $(cat $merged | hash-id) ]] && echo -e $(green true) \
                              || echo -e $(red false))
    stderr-msg -n
    stderr-msg "decoding output -> $merged    (validity: $validity)"
    stderr-msg
    echo -n $merged
}

decode () {
    # -- the outermost decoding wrapper function
    #
    # -> filepath of merged files
    # <- $1: dir containing files to be decoded
    # <- $2: output dirname where the merged file will be located

    # print getting encode started
    stderr-msg -n "."
    stderr-msg "decoding input <- $(abspath $1)"

    cd $1

    # where restored files are collected
    local restored=".$(random-hex 16)"
    assert-dir "$restored"

    # decoding from images
    for f in *; do
        decode-qrcode-image $f $restored $ratio
    done

    # move to the directory of restored files
    cd "$restored"

    # merge files
    for _hash in $(find-hashes-of-uniq-files); do
        echo $(merge-decoded-files $2 $_hash)
    done

}


print-help () {
    local this=$(basename $0)
    cat << HELP
 qed - backup using QR encode/decode

 . encode :: [FILE] -> DIR

      $this -e [-o OUT-DIR] [-s CELL-SIZE] [-m MARGIN]
             [-v VERSION] [-l ERROR-CORRECTION-LEVEL] [-t DATA-TYPE]
             [-1 QR-COLOR-FG] [-0 QR-COLOR-BG] [-p] [-q] FILE ...


 . decode :: DIR -> [FILE]

      $this -d [-r RESIZE-RATIO(%) ] [-o OUT-FILE] DIR


 options:
      -p    Create and play QRcode slideshows after encoding is finished
      -q    Open output QRcode images in browser after encoding is finished
      -s    Set cell size of QRcode"         (default: $QR_CELL_SIZE)
      -m    Set margin of QRcode             (recommended 4+, default: $QR_MARGIN)
      -1    Set foreground color of QRcode   (6-hexadecimal, default: $QR_FOREGROUND)
      -0    Set background color of QRcode   (6-hexadecimal, default: $QR_BACKGROUND)
      -r    Set resize-ratio if needed       (6-hexadecimal, default: $QR_RESIZE_RATIO)
      -v    Set version of QRcode            (1 to 40, default: $QR_VERSION)
      -l    Set QR error correction level    (one of [L,M,Q,H], default: $QR_ERROR_CORRECTION)
      -t    Set type of input data           (one of [A,B,D,K,N], default: $QR_DATA_TYPE)
            A-Alphanumeric, B-Binary, D-Databits, K-Kanji, and N-Numeric
HELP
}



# --------------
# env setting
# --------------
# process options
while getopts edqps:m:o:0:1:r:v:l:t: flag
do
    case "${flag}" in
        e) enc=${OPTARG:-set};;
        d) dec=${OPTARG:-set};;
        q) view=${OPTARG:-set};;
        p) slideshow=${OPTARG:-set};;
        s) size=${OPTARG};;
        m) margin=${OPTARG};;
        o) out=${OPTARG};;
        0) bcolor=${OPTARG};;
        1) fcolor=${OPTARG};;
        r) ratio=${OPTARG};;
        v) version=${OPTARG};;
        l) level=${OPTARG};;
        t) datatype=${OPTARG};;
    esac
done
shift $((OPTIND - 1))

# set fallbacks
out=${out:-$(sane-temp)}
size=${size:-$QR_CELL_SIZE}
margin=${margin:-$QR_MARGIN}
fcolor=${fcolor:-$QR_FOREGROUND}
bcolor=${bcolor:-$QR_BACKGROUND}
ratio=${ratio:-$QR_RESIZE_RATIO}
version=${version:-$QR_VERSION}
level=${level:-$QR_ERROR_CORRECTION}
datatype=${datatype:-$QR_DATA_TYPE}

capcode=$(gen-capcode $version $level $datatype)

bytes=$(find-max-qr-encoding-byte $capcode)

[[ $bytes == "null" ]] && \
    error "failed to get QR-max-encoding-byte." \
          "\n\t check if the values of -l, -t, and -v are set correctly."

# clean and assert default output directory
assert-dir $out



# --------------
# qed main
# --------------
if [ ! -p /dev/stdin ] && [ $# -eq 0 ]; then
    print-help
    exit 0
else
    # when encode-mode: ---------------------------------------------------
    if [ -n $enc ] && [ -z $dec ]; then

        # when used with <stdin>: cat FILE | qed -e
        if [ -p /dev/stdin ]; then
            buf="$(</dev/stdin)"
            buf_name="/dev/stdin"
            encode "$out"       \
                   "$buf"       \
                   "$buf_name"  \
                   "$bytes"     \
                   "$size"      \
                   "$margin"    \
                   "$version"   \
                   "$level"     \
                   "$fcolor"    \
                   "$bcolor"
            stderr-msg
            echo "$out"
            exit 0

            # when used with args: qed -e FILE1 FILE2 FILE3 ...
        else
            for f in "${@}"; do
                popd &>/dev/null; pushd `pwd` &>/dev/null;
                [[ ! -f $f ]] && error "file not found or illegal file: $f"

                buf="$(cat $f)"
                buf_name=$(abspath $f)
                encode "$out"       \
                       "$buf"       \
                       "$buf_name"  \
                       "$bytes"     \
                       "$size"      \
                       "$margin"    \
                       "$version"   \
                       "$level"     \
                       "$fcolor"    \
                       "$bcolor"
            done
            stderr-msg
            echo "$out"
            exit 0
        fi

        # when decode-mode: ---------------------------------------------------
    elif [ -z $enc ] && [ -n $dec ]; then

        # when used with <stdin>: echo DIR | qed -d
        if [ -p /dev/stdin ]; then
            dir="$(</dev/stdin)"

            # when used with args: qed -d DIR
        else
            dir=$1
            [[ ! -d $dir ]] && error "used illegal directory: $dir"

        fi
        [ -z $dir ] && error "empty input: nothing to decode"
        decode $dir $out
        exit 0
    else
        error "choose either '-e' for encode or '-d' for decode."
    fi
fi

# q.e.d.

__QR_MAX_BYTES_DEF__
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
