#!/bin/bash

# Prerequisite ----------------------------------------
# $ brew install zbar qrencode imagemagick ffmpeg

# Edit-Zone -------------------------------------------

# splitter binary
SPLITTER=split

# hasher binary
HASHER=sha256sum

# file compressor binary
ZIPPER=gzip

# default QR-error-correction-level: one of [L,M,Q,H]
QR_ERROR_CORRECTION=L

# default minimum of QR-version: an integer between 1 and 40
QR_VERSION=38

# default type of input data: one of [A,B,K]
QR_DATA_TYPE=B

# default QR-cell size
QR_CELL_SIZE=15

# default cell margin in QR Code area
QR_MARGIN=8

# default foreground-color of QR Code [6-hexadecimal]
QR_FOREGROUND="000000"

# default background-color of QR Code [6-hexadecimal]
QR_BACKGROUND="ffffff"

# default image ratio to original when resizing
QR_RESIZE_RATIO=25%

# default framerate when playing slideshow
SLIDE_SHOW_FRAMERATE=0.5


# Header Definition ---------------------------------------------------

# the header bytes are to provide some information when decoded.
#
# header(HEADER_BYTES) := [hash:HASH_ID_BYTES]
#                       + [index:INDEX_BYTES]
#                       + [size:INDEX_BYTES]

HASH_ID_BYTES=6

INDEX_BYTES=3

HEADER_BYTES=$(($HASH_ID_BYTES + ${INDEX_BYTES}*2))

# 'capcode' or Capaicty-Code means the amount of data can be stored.
# This consists of version, error correction level and the data type
#
# capcode = [version:1-byte]
#         + [error-coorection-level:2-byte]
#         + [datatype:1-byte]
#
# version: one of [L,M,Q,H]
# error-correction-level: 1 to 40 (padded two-digit, %02d)
# datatype: one of [A,B,K]
#   A for alphanumeric (A-Z0-9 + some specials)
#   B for binary (8-bit bytes)
#   K for kanji (kanji byte value)

# ---------------------------------------------------------------------

stderr-msg () {
    # -> stderr messages
    # <- $@: all messages passed
    if [[ -n $verbose || $1 -gt 0 ]]; then
        shift
        >&2 echo
        >&2 echo -e "$@" "\t"
    fi
}


error () {
    # -> exit status
    # <- $@: all messages passed
    stderr-msg 1 $(red error) "\t" $@
    exit 1
}

ok () {
    # -> exit status
    # <- $1: ok message
    stderr-msg 1 -n $(green ok) "\t"
    echo $1
}

red () {
    # -> ansi-escaped text
    # <- $1: text to colorize red
    echo -e "\033[0;31m$1\033[0m"
}


green () {
    # -> ansi-escaped text
    # <- $1: text to colorize green
    echo -e "\033[0;32m$1\033[0m"
}


abspath () {
    # -> absolute path
    # <- $1: filepath
    local dir=$(cd $(dirname $1); pwd -P)
    local fname=$(basename $1)
    echo -n $dir/$fname;
}


lower () {
    # -> lowercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print lc'
}


upper () {
    # -> uppercase string
    # <- $1: string to convert
    echo -n "$1" | perl -ne 'print uc'
}


hash-id () {
    # -- get a hash value using a given hasher
    #
    # -> sized hex-string
    # <- $1: filename - if not provided, use stdin
    if [ $# -gt 0 ]; then
        # when used with args: hash-id STRING
        echo -n $($HASHER "$1" | head -c $HASH_ID_BYTES)
    else
        # when used with stdin: cat FILE | hash-id
        echo -n $(cat - | $HASHER | head -c $HASH_ID_BYTES)
    fi
}


random-bytes () {
    echo -n $(cat /dev/urandom | head -c 32)
}


tmp-filepath () {
    # -> tmp filepath string
    echo -n "/tmp/$(random-bytes | $HASHER | head -c 16)"
}


assert-dir () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -rf $1; mkdir -p $1
}


assert-file () {
    # -> void
    # <- $1: filepath
    are-you-sure $1 && rm -f $1; :> $1
}


are-you-sure () {
    # -> exit status
    # <- $1: filepath
    if [ -e "$1" ]; then
        >&2 echo
        read -n 1 -rp "Are you sure to delete $1? [y/N] " < /dev/tty
        >&2 echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            return 0
        else
            exit 1
        fi
    else
        return 0
    fi
}


decimal-to-binary () {
    # -> binary-form string
    # <- $1: decimal-form string
    # <- $2: (optional) size of output. if not provided, use the minimum length
    local n=$1
    local size=$2
    if [ -z $size ]; then
        while true; do
            size=$((size + 1))
            [[ $n -lt $((2 ** $size)) ]] && break
        done
    fi

    local r=
    for _ in $(seq $size); do
        b="$b$(echo -n $(($n & 1)))"
        ((n >>= 1))
    done
    echo -n $b | rev
}


select-data-type () {
    # -> datatype string
    # <- $1: datatype char
    case $1 in
        A) echo -n "Alphanumeric";;
        B) echo -n "Binary";;
        K) echo -n "Kanji";;
        *) error "no such value for data type: $1";;
    esac
}


get-capcode () {
    # -> capcode-string
    # <- $1: version
    # <- $2: correction level
    # <- $3: datatype
    echo -n "$(printf %02d $version)$level$datatype"
}


find-max-qr-encoding-byte () {
    # -- find maximum bytes that can be encoded with the given capcode,
    # -- combinations of version, error correction level, and datatype
    # --
    # -> max-QR-storage-byte number
    # <- $1: capcode
    local datatype=$(select-data-type $datatype)
    [[ -n $datatype ]] || error "no such capcode exists: $1"

    local filter="${1:0:2}_${1:2:1}_$datatype"
    grep -A 1 "^__QR_MAX_BYTES_DEF__$" $0 | tail -1             \
                                          | base64 -d           \
                                          | gunzip -c           \
                                          | grep "$filter"      \
                                          | awk -F: '{print$2}' \
        || error "problems finding QR Code max-encoding bytes: $filter"
}


split-data () {
    # -- split the given buffer if large enough
    #
    # -> void
    # <- $1: in
    # <- $2: bytes
    # <- $3: prefix
    $SPLITTER -b $(($2 - $HEADER_BYTES)) -a ${INDEX_BYTES} "$1" "$3" \
        || error "occurred problem while splitting data in: $(pwd)"
}


write-header-and-qrencode () {
    # -- write a header to each token and encode it into a QR Code
    #
    # -> void
    # <- $1: _hash
    # <- $2: size
    # <- $3: margin
    # <- $4: version
    # <- $5: level
    # <- $6: fcolor
    # <- $7: bcolor
    stderr-msg 0 -n "."
    local total=$(printf %0${INDEX_BYTES}d $(ls -1 _ | wc -l))
    local it=1
    for f in $(ls -1 _ | sort); do
        local o="$f.png"
        local header="$1$(printf %0${INDEX_BYTES}d $it)$total"
        stderr-msg 0 -n "processing  $1" \
                        "[$(printf %0${INDEX_BYTES}d $it) / $total]  >>  $(pwd)/$o"

        # write header to split file
        echo -n $header | cat - "_/$f" > _/_ && mv _/_ "_/$f"

        # encode each split file into QR Code
        cat "_/$f" | qrencode -8               \
                              -s $2            \
                              -m $3            \
                              -v $4            \
                              -l $5            \
                              -o $o            \
                              --foreground=$6  \
                              --background=$7  \
            || error "occurred problem while encoding data into QR Code: $(pwd)/$f"
        it=$((it+1))
    done
    rm -rf _
}


create-video-and-play-slideshow () {
    # -> void
    # <- $1: video-file-basename
    local mp4="$1.mp4"
    local n=$(ls -1 *.png | wc -l)
    local t=$(echo "scale=0;1/$SLIDE_SHOW_FRAMERATE*$n+2" | bc)
    stderr-msg 0 "generating $mp4"

    # converting encoded images into video file
    ffmpeg -y -hide_banner                   \
           -loglevel error                   \
           -stats                            \
           -loop 1                           \
           -framerate $SLIDE_SHOW_FRAMERATE  \
           -t $t                             \
           -pattern_type glob                \
           -i '*.png'                        \
           -s hd720                          \
           $mp4                              \
        || error "occurred problem while creating the slideshow: $mp4"
    stderr-msg 0 "opening $mp4"
    open $mp4
}


quick-view-on-browser () {
    # -> void
    # <- $1: html-file-basename
    local html="$1.html"
    echo -e "<!DOCTYPE html>" > $html
    echo -e "<head><title>qed-encoded</title></head>" >> $html
    echo -e "<body><center>" >> $html
    for f in $(ls -1 | sort); do
        echo -e "<p><img src=\"$(abspath $f)\" width="1000"></p>" >> $html
    done
    echo -e "</center></body><html>" >> $html
    stderr-msg 0 "opening $html"
    open $html
}


encode () {
    # -- the outermost encoding wrapper function
    # -- single encoding process is performed for a given file
    #
    # -> void
    # <- $1: out
    # <- $2: in
    # <- $3: size
    # <- $4: margin
    # <- $5: version
    # <- $6: level
    # <- $7: fcolor
    # <- $8: bcolor

    # get capcode or capaicty-code, expected 4-byte like '40LB',
    # means the amount of data can be stored.
    capcode=$(get-capcode $version $level $datatype)

    # get maximum bytes that can be encoded with the given capcode
    bytes=$(find-max-qr-encoding-byte $capcode)

    # guard on 'bytes' variable
    [[ -z $bytes ]] && \
        error "failed to get QR-max-encoding-byte." \
              "\n\t check if the values of -l, -t, and -V are set correctly."

    # get a hash-id-key for data
    local _hash=$(hash-id "$2")

    # tmp working directory
    t=$(tmp-filepath)
    assert-dir "$t/_"
    cd $t

    # split the given buffer if it is large enough
    split-data "$2" $bytes "$t/_/${_hash}-"

    # try QR-encoding with the generated header
    write-header-and-qrencode $_hash \
                              $3     \
                              $4     \
                              $5     \
                              $6     \
                              $7     \
                              $8

    stderr-msg 0 "completed.  each QR Code encoded in:" \
                 "$bytes bytes (including ${HEADER_BYTES}-byte header)\n"

    # quick-view encoded images on browser (if -q is set)
    [[ -n $view ]] && quick-view-on-browser "$t-$capcode"

    # play slideshow after generating video from images (if -p is set)
    [[ -n $slideshow ]] && create-video-and-play-slideshow "$t-$capcode"

    # output: write to file or to stdout in tar format
    if [ -n "$1" ]; then
        ls -1 *.png | tar -cf "$1" -T - \
            && ok "$1" \
            || error "problem occurred while writing to file: $1"
    else
        ls -1 *.png | tar -c -T - \
            || error "problem occurred while writing to stdout"
    fi
}


decode-qrcode-image () {
    # -> void
    # <- $1: qrcode image file
    # <- $2: dirname where decoded files are collected
    # <- $3: resize ratio to original

    # resize
    convert -resize "${3}%" $1 __ \
        || error "occurred problem during resizing QR Code image: $1"

    # decode each iamge using zbar
    zbarimg --raw --quiet -Sbinary __ > _ \
        || error "occurred problem during decoding QR Code image: $1"

    # parse header
    local header=$(cat _ | head -c $HEADER_BYTES)
    [[ ${#header} -eq $HEADER_BYTES ]] \
        || error "something wrong with the header: $header"

    stderr-msg 0 -n \
                 "processing  ${header:0:$HASH_ID_BYTES}" \
                 "[${header:$HASH_ID_BYTES:$INDEX_BYTES} /" \
                 "${header:$((HEADER_BYTES-$INDEX_BYTES)):$INDEX_BYTES}]" \
                 " <<  $1"
    cat _ | tail -c +$((HEADER_BYTES + 1)) > "$2/$header"
    rm -f __ _
}

find-hashes-of-uniq-files () {
    # -> many hash strings (blank separated)
    # no input, but this function depends on the directory location.
    local awk=`echo {print substr\(\\$0,3,$HASH_ID_BYTES\)}`
    echo -n $(find . -size +0c | awk "$awk" | sort | uniq)
}

merge-decoded-files () {
    # -> void
    # <- $1: filepath of merged files
    # <- $2: hash value that the merged file is expected to have
    local f="$1/$2"
    ls -1 | grep $2 | sort | xargs cat > $f \
        || error "problem occurred during merging decoded files: $f"

    # check if the decoded is valid
    [[ "$2" == "$(cat $f | hash-id)" ]] \
        || error "Not matched hash value of file: $f" \
                 "\n\t expected $2, but got $(cat $f | hash-id)"
}

decode () {
    # -- the outermost decoding wrapper function
    #files
    # <- $1: out: output tarball filename
    # <- $2: dir containing files to be decoded
    stderr-msg 0 -n "."
    cd $2

    # where decoded files are collected
    local decoded="$(tmp-filepath)"
    assert-dir "$decoded"

    # decoding from images
    for f in $(find . | file --mime -f -       \
                      | grep "image/*"         \
                      | awk -F: '{print$1}'    \
                      | sort); do
        decode-qrcode-image $f $decoded $ratio \
            || error "failed to decode QR code image: $f"
    done

    cd "$decoded"

    # merge files
    local merged=$(tmp-filepath)
    assert-dir $merged
    for _hash in $(find-hashes-of-uniq-files); do
        merge-decoded-files $merged $_hash \
            || error "failed to merge files with expected hash of: $_hash"
    done

    cd "$merged"

    # extract decoded archives
    for f in *; do
        tar -xf $f \
            || error "failed to extract decoded archive: $f"
        rm -f $f
    done

    # output
    stderr-msg 0
    if [ -n "$1" ]; then
        mv -f $merged "$1"
        ok "$1"
    else
        find . -type f | sort | xargs cat
    fi
}


print-help () {
    local this=$(basename $0)
    cat << HELP
 qed - encode data of any size into tarballs of QR Code

 Usage: $this [-hdpqzv] [-o output] [-s cell-size] [-m margin]
            [-V version] [-l error-correction-level] [-t data-type]
            [-1 qr-fg-color] [-0 qr-bg-color] [-r resize-ratio ] filepath

      -h    print this message
      -d    decode input
      -p    create and play QR Code slideshows after encoding is finished
      -q    open output QR Code images in browser after encoding is finished
      -z    compress output tarball of QR code
      -v    show in detail how the work is progressing
      -o    set output file                  (default: '-' for stdout)
      -s    set cell size of QR Code         (default: $QR_CELL_SIZE)
      -m    set margin of QR Code            (recommended 4+, default: $QR_MARGIN)
      -1    set foreground color of QR Code  (6-hexadecimal, default: $QR_FOREGROUND)
      -0    set background color of QR Code  (6-hexadecimal, default: $QR_BACKGROUND)
      -r    set resize-ratio if needed       (6-hexadecimal, default: $QR_RESIZE_RATIO)
      -V    set version of QR Code           (1 to 40, default: $QR_VERSION)
      -l    set error correction level       (one of [L,M,Q,H], default: $QR_ERROR_CORRECTION)
      -t    set type of input data           (one of [A,B,K], default: $QR_DATA_TYPE)
                                             A: Alphanumeric, B: Binary, and K: Kanji
HELP
    exit 0
}



# --------------
# qed main
# --------------
# process options
while getopts hdpqzvo:s:m:1:0:r:V:l:t: flag
do
    case "${flag}" in
        h) print-help;;
        d) decode=${OPTARG:-set};;
        p) slideshow=${OPTARG:-set};;
        q) view=${OPTARG:-set};;
        z) zip=${OPTARG:-set};;
        v) verbose=${OPTARG:-set};;
        o) out=${OPTARG};;
        s) size=${OPTARG};;
        m) margin=${OPTARG};;
        1) fcolor=${OPTARG};;
        0) bcolor=${OPTARG};;
        r) ratio=${OPTARG};;
        V) version=${OPTARG};;
        l) level=${OPTARG};;
        t) datatype=${OPTARG};;
    esac
done
shift $((OPTIND - 1))

# set fallbacks
size=${size:-$QR_CELL_SIZE}
margin=${margin:-$QR_MARGIN}
fcolor=${fcolor:-$QR_FOREGROUND}
bcolor=${bcolor:-$QR_BACKGROUND}
ratio=${ratio:-$QR_RESIZE_RATIO}
version=${version:-$QR_VERSION}
level=${level:-$QR_ERROR_CORRECTION}
datatype=${datatype:-$QR_DATA_TYPE}
[[ $out == "-" ]] && out=


# decoding:
if [[ -n $decode ]]; then

    # when used with stdin
    if [[ -p /dev/stdin || $# -eq 0 ]]; then
        in="$(tmp-filepath)"
        assert-dir "$in"
        cat - | tar -x -C "$in" &>/dev/null \
            || error "entered an unacceptable format: must be a tarball or dir"

    # when used with arguments
    else
        f="$1"
        [[ ! -e $f ]] && error "filepath not found: $f"
        if [ -d $f ]; then
            in=$f
        else
            tar -tf $f &>/dev/null \
                || error "the target to be decoded must be a tarball or dir: $f"
            in="$(tmp-filepath)"
            assert-dir "$in"
            tar -xf $f -C "$in"
        fi
    fi

    # check if there's anything to decode
    [[ $(find $in | file --mime -f -     \
                  | grep "image/*"       \
                  | awk -F: '{print$1}'  \
                  | wc -l) -gt 0 ]]      \
        || error "nothing to decode: $1"

    # prepare output name (if any). stdout by default
    if [ -n "$out" ]; then
        out=$(abspath $out)
        are-you-sure $out && rm -rf $out
    fi
    decode "$out" "$in"


# encoding:
else
    # when used with stdin
    if [[ -p /dev/stdin || $# -eq 0 ]]; then
        f="$(tmp-filepath)"
        cat - > $f

    # when used with arguments
    else
        f="$1"
        [[ ! -e $f ]] && error "filepath not found: $f"
    fi

    # prepare output name (if any). stdout by default
    if [ -n "$out" ]; then
        out=$(abspath $out)
        are-you-sure $out && rm -rf $out
    fi

    # prepare input file to encode
    in="$(tmp-filepath).tar.gz"
    cd $(dirname $f) && tar -c $(basename $f) | $ZIPPER -c > $in \
        || error "problem occurred while archiving file: $f"

    encode "$out"      \
           "$in"       \
           "$size"     \
           "$margin"   \
           "$version"  \
           "$level"    \
           "$fcolor"   \
           "$bcolor"
fi

exit 0
# q.e.d.

__QR_MAX_BYTES_DEF__
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
