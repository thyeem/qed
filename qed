#!/bin/bash

# PREREQUISITE ----------------------------------------
# $ brew install zbar qrencode coreutils imagemagick

# EDIT-ZONE -------------------------------------------

# splitter binary
SPLITTER=gsplit

# hasher binary
HASHER=sha256sum

# default output path when encoding
ENCODED_QR_DIR=/tmp/.q

# default output path when decoding
DECODED_FILE=/tmp/q

# file defining max-byte of QRcode
QR_MAX_BYTES_DEF_FILE=${PWD}/qr_alltype_capacity.json

# default QR-error-correction-level: one of [L,M,Q,H]
QR_ERROR_CORRECTION=L

# default minimum of QR-version: 1-40
QR_VERSION=38

# default QR-cell size
QR_CELL_SIZE=15

# default cell margin in QRcode area
QR_MARGIN=8

# default foreground-color of QRcode [6-hexadecimal]
QR_FOREGROUND="000000"

# default background-color of QRcode [6-hexadecimal]
QR_BACKGROUND="ffffff"

# default image ratio to original when resizing
QR_RESIZE_RATIO=25%

# default type of input data: one of [A,B,D,K,N]
# alphanumeric, binary, databits, kanji, and numeric, respectively
QR_DATA_TYPE=B


# HEADER OF DATA TOKEN --------------------------------
#
# header(HEADER_BYTES) := [hash:HASH_ID_BYTES]
#                       + [index:INDEX_BYTES]
#                       + [size:INDEX_BYTES]
#
# make sure that HEADER_BYTES == (HASH_ID_BYTES + INDEX_BYTES * 2)

HEADER_BYTES=12

HASH_ID_BYTES=6

INDEX_BYTES=3

# -----------------------------------------------------


red () {
    echo -e "\033[0;31m$1\033[0m"
}

green () {
    echo -e "\033[0;32m$1\033[0m"
}

realpath () {
    # $1: filepath
    dir=$(cd $(dirname $1); pwd -P)
    fname=$(basename $1)
    if [ -d $fname ]; then
        echo -n $dir;
    else
        echo -n $dir/$fname;
    fi
}

hash-id () {
    # $1: filepath
    echo -n $($HASHER $1 | head -c ${HASH_ID_BYTES})
}

assert-dir () {
    # $1: filepath
    rm -rf $1; mkdir -p $1
}

assert-file () {
    # $1: filepath
    rm -f $1; :> $1
}

set-value-or-default () {
    # $1: variable
    # $2: default-value
    echo -n ${1:-$2}
}

select-data-type () {
    case $1 in
        A) echo -n "Alphanumeric";;
        B) echo -n "Binary";;
        D) echo -n "Databits";;
        K) echo -n "Kanji";;
        N) echo -n "Numeric";;
        *) echo "No such value for data type: $1"; exit 1;;
    esac
}


while getopts edqs:m:o:0:1:r:v:l:t: flag
do
    case "${flag}" in
        e) enc=${OPTARG:-undefined};;
        d) dec=${OPTARG:-undefined};;
        q) view=${OPTARG:-/tmp/.q.html};;
        s) size=${OPTARG};;
        m) margin=${OPTARG};;
        o) out=${OPTARG};;
        0) bcolor=${OPTARG};;
        1) fcolor=${OPTARG};;
        r) ratio=${OPTARG};;
        v) version=${OPTARG};;
        l) level=${OPTARG};;
        t) datatype=${OPTARG};;
    esac
done

shift $(($OPTIND - 1))
input=$1


# HELP:
if [ $# -eq 0 ]; then
    this=$(basename $0)
    cat << HELP
 qed - backup using QR encode/decode

 [encode]
     $this -e [-o OUT-DIR] [-s CELL-SIZE] [-m MARGIN]
            [-v VERSION] [-l ERROR-CORRECTION-LEVEL] [-t DATA-TYPE]
            [-1 QR-COLOR-FG] [-0 QR-COLOR-BG] [-q] FILE

 [decode]
     $this -d [-r RESIZE-RATIO(%) ] [-o OUT-FILE] DIR


 options:
      -q    Open output images to browser when encoding is finished"
      -s    Set cell size of QR-code"         (default: $QR_CELL_SIZE)
      -m    Set margin of QR-code             (recommended 4+, default: $QR_MARGIN)
      -1    Set Foreground color of QR-code   (6-hexadecimal, default: $QR_FOREGROUND)
      -0    Set Background color of QR-code   (6-hexadecimal, default: $QR_BACKGROUND)
      -r    Set resize-ratio if needed        (6-hexadecimal, default: $QR_RESIZE_RATIO)
      -v    Set version of QR-code            (1 to 40, default: $QR_VERSION)
      -l    Set QR error correction level     (one of [L,M,Q,H], default: $QR_ERROR_CORRECTION)
      -t    Set type of input data            (one of [A,B,D,K,N], default: $QR_DATA_TYPE)
            A-Alphanumeric, B-Binary, D-Databits, K-Kanji, and N-Numeric
HELP

# OTHERWISE:
else
    # ENCODE-MODE
    if [ ! -z $enc ] && [ -z $dec ]; then
        # set fallbacks
        size=$(     set-value-or-default  $size      $QR_CELL_SIZE)
        margin=$(   set-value-or-default  $margin    $QR_MARGIN)
        out=$(      set-value-or-default  $out       $ENCODED_QR_DIR)
        fcolor=$(   set-value-or-default  $fcolor    $QR_FOREGROUND)
        bcolor=$(   set-value-or-default  $bcolor    $QR_BACKGROUND)
        version=$(  set-value-or-default  $version   $QR_VERSION)
        level=$(    set-value-or-default  $level     $QR_ERROR_CORRECTION)
        datatype=$( set-value-or-default  $datatype  $QR_DATA_TYPE)

        # set jq-query-filter
        datatype=$(select-data-type $datatype)
        filter=\"${version}_${level}_${datatype}\"

        # read max-qrcode-bytes
        bytes=$(cat ${QR_MAX_BYTES_DEF_FILE} | jq ".$filter")

        # clean and assert default output-dir
        assert-dir $out

        # split the data if large enough
        split_bytes=$(($bytes - $HEADER_BYTES))
        cat $input | $SPLITTER -d -b ${split_bytes} -a ${INDEX_BYTES} - "$out/image-"

        # get a unique id for data
        _hash=$(hash-id $input $HASH_ID_BYTES)

        # move and get info
        cd $out
        len=`printf %0${INDEX_BYTES}d $(ls -1 | wc -l)`

        # write header to each token
        it=1
        for f in *
        do
            header="${_hash}$(printf %0${INDEX_BYTES}d $it)${len}"
            echo -n $header > "${f}_"
            cat $f >> "${f}_"
            mv -f "${f}_" $f
            it=$((it+1))
        done

        # encoding into QRcode
        for f in *
        do
            o="${f}.png"
            >&2 echo "processing  $out/$o"
            cat $f | qrencode -8 -s $size -m $margin -v $version -l $level -o $o \
                              --foreground=$fcolor --background=$bcolor
            rm -f $f
        done

        >&2 echo
        >&2 echo "QR-code encoded in:" \
                 "$bytes bytes (including ${HEADER_BYTES}-byte header)"
        >&2 echo
        >&2 echo "encoding output -> $out"
        >&2 echo
        echo "$out"

        # quick-view encoded images on browser if set -q
        if [ ! -z $view ]; then
            assert-file $view
            echo -e "<!DOCTYPE html>" >> $view
            echo -e "<head><title>qed-encoded</title></head>" >> $view
            echo -e "<body><center>" >> $view
            for f in *
            do
                echo -e "<p><img src=\"$(realpath $f)\" width="1000"></p>" >> $view
            done
            echo -e "</center></body><html>" >> $view
            open $view
        fi

    # DECODE-MODE
    elif [ -z "$enc" ] && [ ! -z "$dec" ]; then
        # set fallbacks
        out=$(   set-value-or-default  $out   $DECODED_FILE)
        ratio=$( set-value-or-default  $ratio $QR_RESIZE_RATIO)

        # move and get info
        cd $input
        >&2 echo "total $(ls -1 | wc -l) files"
        len=`printf %0${INDEX_BYTES}d $(ls -1 | wc -l)`

        # clean and assert workplace
        t=$(echo $RANDOM | md5 | head -c 6)
        assert-dir ".$t"

        # decoding from images
        for f in *
        do
            base=$(basename ${f%.*})
            g="${base}-resized.jpg"
            q="${base}-decoded"

            # resize
            convert -resize "${ratio}%" $f $g

            # decode each iamge using zkbar
            zbarimg --raw --quiet -Sbinary $g > $q

            # parse header
            header=$(cat $q | head -c $HEADER_BYTES)
            >&2 echo "processing  ${header:0:$HASH_ID_BYTES}" \
                     "[${header:$HASH_ID_BYTES:$INDEX_BYTES}" \
                     "/" \
                     "${header:$((HEADER_BYTES-$INDEX_BYTES)):$INDEX_BYTES}]"
            cat $q | tail -c +$((HEADER_BYTES+1)) > ".$t/$header"
            rm -f $g $q
        done

        # move to workplace
        cd ".$t"
        awk=`echo {print substr\(\\$0,3,$HASH_ID_BYTES\)}`
        kinds=$(find . -size +0c | awk "$awk" | sort | uniq)

        # merge files
        for k in $kinds
        do
            kout="${out}-$k"
            ls -1 | grep $k | sort | xargs cat > $kout

            # check if the decoded is valid
            validity=$([[ "$k" == $(hash-id $kout $HASH_ID_BYTES) ]] \
                       && echo -e $(green true) \
                       || echo -e $(red false))
            >&2 echo
            >&2 echo "decoding output -> $kout    (validity: $validity)"
            >&2 echo
            echo $kout
        done

    else
        echo "Choose either '-e' for encode or '-d' for decode."
    fi
fi
